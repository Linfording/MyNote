代理模式
	代理模式的价值:
		通过代理访问，实现对真实访问对象的隐藏，对真实业务请求的拦截。拦截下来后可以根据场景需求自己进行一些额外的处理操作，将一些琐碎的业务提取到代理类中，同真实业务逻辑区分开来，方便代码的管理维护。
	静态代理
		静态代理中代理类的字节码在运行前就已经由程序员编写完成，每有一个委托类就实现一个代理类。静态代理的实现方式比较灵活，代理类委托类实现同一接口来实现代理，或者代理类继承委托类来实现代理。委托类的每个方法，代理类都可以实现不一样的自定义代理。
	动态代理
		动态代理中代理类的字节码是在运行时通过反射生成的，代理类统一由工厂类来创建，不需要程序员写死。静态代理的时候，会遇到代理的业务相同而委托类不同的情况，这种情况下静态代理要为每个委托类都实现一一对应的代理类，这样会照成代码冗余，重复，采用动态代理可以把相同的代理业务提取出来统一自动生成即可，不需要编写，降低了代码的复杂程度提高了可维护性。

	静态代理的效率会高于动态代理，因为静态代理的代理类是在运行前就确定的，而动态代理的代理类需要在运行时生成。当委托类有多个方法需要实现不同的代理业务时，静态代理才能满足需求，动态代理的所有方法都会进到统一的代理方法里。但是项目如果需要使用静态代理来满足需求，说明项目的耦合度过高，复用性低了，业务细分的不够。
	较为合理的项目都是采用动态代理的方法来控制访问，因为项目一旦过大的时候，静态代理的方式只会增加代码的冗余和复杂程度，提高维护难度。
		JDK动态代理
			jdk动态代理，jdk封装API，使用Proxy.newProxyInstance()方法来实现动态代理，这个方法由三个参数
			1.classload，指定由哪个类加载器加载
			2.interface[]，委托类实现的接口
			3.InXXXXX的一个接口，里面的Invoke方法就是代理类的业务方法。
			委托类一旦被委托，调用者通过代理类调用委托类的所有方法时都会走到这个invoke方法里，然后委托类方法被调用。
		cglib动态代理
			cglib动态代理由第三方提供，导入cglib的jar包
			创建增强器enhancer
			设置接口，设置父类,设置回调，调用enhancer.create()生成代理类。
			设置接口，或者设置父类，设置其中一个均可实现动态代理。
			代理类的业务方法在回调接口中
			MethodIntercpt()接口，其中的intercpt方法相当于jdk代理的invoke方法，调用者调用通过代理类调用委托类的所有方法时都会走到这个intercpt方法里，然后委托类的方法被调用
		区别:
			JDK动态代理一定要委托类实现某个接口，代理类同委托类实现相同的接口，这样来实现。而cglib代理可以在委托类没有实现接口的时候对其进行代理，通过继承的方式来实现代理的，所以设置接口如果没有也可以不设置。
			cglib如果设置了接口的情况下将会使用接口实现代理，如果没有设置接口将会使用继承实现。cglib动态代理效率略高于jdk动态代理，因为cglib底层是通过二进制码实现的。
