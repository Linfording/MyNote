多线程问题
1.多线程的三种启动方式
	
1.1继承Thread类实现多线程
	创建自己的线程类:
	public class MyThread extends Thread {  
	　　public void run() {  
	　　 System.out.println("MyThread.run()");  
	　　}  
	}  
	启动:
	MyThread myThread1 = new MyThread();  
	MyThread myThread2 = new MyThread();  
	myThread1.start();  
	myThread2.start();  

1.2实现Runnable接口方式实现多线程
	创建自己的线程类:
	public class MyThread extends OtherClass implements Runnable {  
	　　public void run() {  
	　　 System.out.println("MyThread.run()");  
	　　}  
	}  
	
	为了启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例：
	MyThread myThread = new MyThread();  
	Thread thread = new Thread(myThread);  
	thread.start(); 

1.3使用ExecutorService、Callable、Future实现有返回结果的多线程
	ExecutorService、Callable、Future这个对象实际上都是属于Executor框架中的功能类。想要详细了解Executor框架的可以访问http://www.javaeye.com/topic/366591 ，这里面对该框架做了很详细的解释。返回结果的线程是在JDK1.5中引入的新特征，确实很实用，有了这种特征我就不需要再为了得到返回值而大费周折了，而且即便实现了也可能漏洞百出。
	可返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下：

2.线程同步的方式:

2.1 synchronized同步方法
	即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
	注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。
		给一个方法增加synchronized修饰符之后就可以使它成为同步方法，这个方法可以是静态方法和非静态方法，但是不能是抽象类的抽象方法，也不能是接口中的接口方法。

2.2 synchronized同步代码块
	即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步
	synchronized(object){ 
	}
	注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。
	 package com.xhj.thread;
 
    /**
     * 线程同步的运用
     * 
     * @author XIEHEJUN
     * 
     */
    public class SynchronizedThread {
        class Bank {
            private int account = 100;
            public int getAccount() {
                return account;
            }
            /**
             * 用同步方法实现
             * @param money
             */
            public synchronized void save(int money) {
                account += money;
            }
            /**
             * 用同步代码块实现
             * @param money
             */
            public void save1(int money) {
                synchronized (this) {
                    account += money;
                }
            }
        } 
        
        class NewThread implements Runnable {
            private Bank bank;
 
            public NewThread(Bank bank) {
                this.bank = bank;
            }
 
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    // bank.save1(10);
                    bank.save(10);
                    System.out.println(i + "账户余额为：" + bank.getAccount());
                }
            }
 
        }
        /**
         * 建立线程，调用内部类
         */
        public void useThread() {
            Bank bank = new Bank();
            NewThread new_thread = new NewThread(bank);
            System.out.println("线程1");
            Thread thread1 = new Thread(new_thread);
            thread1.start();
            System.out.println("线程2");
            Thread thread2 = new Thread(new_thread);
            thread2.start();
        }
 
        public static void main(String[] args) {
            SynchronizedThread st = new SynchronizedThread();
            st.useThread();
        }
    	
2.3 wait与notify
  	wait()该方法属于Object的方法，wait方法的作用是使得当前调用wait方法所在部分（代码块）的线程停止执行，并释放当前获得的调用wait所在的代码块的锁，并在其他线程调用notify或者notifyAll方法时恢复到竞争锁状态（一旦获得锁就恢复执行）。
  	
	wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
	sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。
	notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
	Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

	调用wait方法需要注意几点：
    第一点：wait被调用的时候必须在拥有锁（即synchronized修饰的）的代码块中。
    第二点：恢复执行后，从wait的下一条语句开始执行，因而wait方法总是应当在while循环中调用，以免出现恢复执行后继续执行的条件不满足却继续执行的情况。
    第三点：若wait方法参数中带时间，则除了notify和notifyAll被调用能激活处于wait状态（等待状态）的线程进入锁竞争外，在其他线程中interrupt它或者参数时间到了之后，该线程也将被激活到竞争状态。
    第四点：wait方法被调用的线程必须获得之前执行到wait时释放掉的锁重新获得才能够恢复执行。


	notify方法通知调用了wait方法，但是尚未激活的一个线程进入线程调度队列（即进入锁竞争），注意不是立即执行。并且具体是哪一个线程不能保证。另外一点就是被唤醒的这个线程一定是在等待wait所释放的锁。
    notifyAll方法则唤醒所有调用了wait方法，尚未激活的进程进入竞争队列。

2.4 使用特殊域变量(volatile)实现线程同步
	a.volatile关键字为域变量的访问提供了一种免锁机制
    b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新
    c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 
    d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 

    例如： 
        在上面的例子当中，只需在account前面加上volatile修饰，即可实现线程同步。 
    
    代码实例： 
        //只给出要修改的代码，其余代码与上同
        class Bank {
            //需要同步的变量加上volatile
            private volatile int account = 100;
 
            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized 
            public void save(int money) {
                account += money;
            }
        }

    注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 
    用final域，有锁保护的域和volatile域可以避免非同步的问题。 
	
2.5 使用重入锁实现线程同步
	在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 
	ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。
	ReenreantLock类的常用方法有：
		ReentrantLock() : 创建一个ReentrantLock实例 
		lock() : 获得锁 
		unlock() : 释放锁 
		
	注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 
        
    例如： 
        在上面例子的基础上，改写后的代码为: 
       //只给出要修改的代码，其余代码与上同
        class Bank {
            
            private int account = 100;
            //需要声明这个锁
            private Lock lock = new ReentrantLock();
            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized 
            public void save(int money) {
                lock.lock();
                try{
                    account += money;
                }finally{
                    lock.unlock();
                }
                
            }
        }
        
    注：关于Lock对象和synchronized关键字的选择： 
        a.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。 
        b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 
        c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 
	
2.6 使用局部变量实现线程同步
	前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 本小节主要是使用LinkedBlockingQueue<E>来实现线程的同步 LinkedBlockingQueue<E>是一个基于已连接节点的，范围任意的blocking queue。 队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~LinkedBlockingQueue 类常用方法 LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue put(E e) : 在队尾添加一个元素，如果队列满则阻塞 size() : 返回队列中的元素个数 take() : 移除并返回队头元素，如果队列空则阻塞代码实例： 实现商家生产商品和买卖商品的同步

 

	注：BlockingQueue<E>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：
	　　add()方法会抛出异常
	　　offer()方法返回false
	　　put()方法会阻塞

	使用原子变量实现线程同步
	需要使用线程同步的根本原因在于对普通变量的操作不是原子的。
	那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作即-这几种行为要么同时完成，要么都不完成。在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。其中AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。

	AtomicInteger类常用方法：
		AtomicInteger(int initialValue) : 创建具有给定初始值的新的
		AtomicIntegeraddAddGet(int dalta) : 以原子方式将给定值与当前值相加
		get() : 获取当前值

	代码实例：

	只改Bank类，其余代码与上面第一个例子同

		class Bank {
		    private AtomicInteger account = new AtomicInteger(100);
		    public AtomicInteger getAccount() {
		        return account; 
		    } 
		    public void save(int money) {
		        account.addAndGet(money);
		    }
		}
		
	补充--原子操作主要有：
	对于引用变量和大多数原始变量(long和double除外)的读写操作；　　
	对于所有使用volatile修饰的变量(包括long和double)的读写操作。

3.ThreadLocal
	ThreadLocal作用:
		不是用来解决对象共享访问问题的，而主要是提供了线程保持对象的方法和避免参数传递的方便的对象访问方式。
		
	ThreadLocal的应用场合:
		最适合的是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。

	ThreadLocal实现:
		1.每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 
		2.将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 
 		3.ThreadLocalMap 类是ThreadLocal中定义的内部类，但是它的实例却用在Thread类中;
 		4.set()将该ThreadLocal实例作为key，要保持的对象作为值，设置到当前线程的ThreadLocalMap 中，get()通过key取出对象值

4.volatile与synchronize的区别
	1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
	2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
	3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
	4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
	5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
	
5.Thread类有哪些静态方法，记熟。很容易出现
	1.currentThread()
		currentThread()方法返回的是对当前正在执行线程对象的引用。
	2.sleep(long millis)
		sleep(long millis)方法的作用是在指定的毫秒内让当前"正在执行的线程"休眠（暂停执行）。这个"正在执行的线程"是关键，指的是Thread.currentThread()返回的线程。根据JDK API的说法，"该线程不丢失任何监视器的所属权"，直白点讲，就是不让出CPU资源。CPU还在执行当前线程run()方法中的代码，无非执行的内容是"睡觉"而已。
	3.yield()
		暂停当前执行的线程对象，并执行其他线程。这个暂停是会放弃CPU资源的，并且放弃CPU的时间不确定，有可能刚放弃，就获得CPU资源了，也有可能放弃好一会儿，才会被CPU执行。
	4.interrupted()
		测试当前线程是否已经中断，执行后具有将状态标识清除为false的功能。

6.线程和进程的区别:
	首先得知道什么是进程什么是线程，我的理解是进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例，是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。线程是系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。进程——资源分配的最小单位，线程——程序执行的最小单位。