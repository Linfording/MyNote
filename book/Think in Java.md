# Think in Java
## 第一章
### 1.对象入门
#### 1.1抽象的进步
Smalltalk 的五大基本特征
(1) 所有东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论
上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。
(2) 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那
28
个对象“发送一条消息”。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个
子例程或函数。
(3) 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所
以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。
(4) 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）
是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。
(5) 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为
“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消
息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括
“圆”。这一特性称为对象的“可替换性”，是OOP 最重要的概念之一。

#### 1.2对象的接口
我们向对象发出
的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类
型”与“接口”的等价或对应关系是面向对象程序设计的基础。
#### 1.3实现方案的隐藏
- **两种涉足面向对象编程的人员：**
>  1. **类的创建者：**创建新数据类型的人
>  对类创建者来说，他们的目标则是从头构建一个类，只向客户程序员开放有必要开放的东西（接口），其他所有细节都隐藏起来。
>  2. **客户程序员：**在自己的应用程序中采用现成数据类型的人
	> 对客户程序员来讲，最主要的目标就是收集一个充斥着各种类的编程“工具
箱”，以便快速开发符合自己要求的应用。

- **接口：**规定了可对一个特定的对象发出哪些请求。
- **隐藏的实现：**然而，必须在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”

- **类边界**
Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private，protected 以及暗示性的friendly。
> - **public:**意味着后续的定义任何人均可使用
> - **private:**意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。 private 在您与客户程序员之间竖起了一堵墙。若有人试图访问私有30成员，就会得到一个编译期错误。
> - **friendly:**涉及“包装”或“封装”（Package）的概念——即Java 用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。
> - **protected:**与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。

#### 1.4方案的重复使用
> 创建并测试好一个类后，它应（从理想的角度）代表一个有用的代码单位。但并不象许多人希望的那样，这种重复使用的能力并不容易实现；它要求较多的经验以及洞察力，这样才能设计出一个好的方案，才有可能重复使用。许多人认为代码或设计方案的重复使用是面向对象的程序设计提供的最伟大的一种杠杆。

- **成员对象：**为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。
- **组织——在现有类的基础上组织一个新类：**新类可由任意数量和类型的其他对象构成。无论如何，只要新类达到了设计要求即可。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。

#### 1.5 继承：重新使用接口
extends
使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏
起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消
息亦可原样发给衍生类的对象。根据可以发送的消息，我们能知道类的类型。这意味着衍生类具有与基础类
相同的类型！为真正理解面向对象程序设计的含义，首先必须认识到这种类型的等价关系。

两种做法可将新得的衍生类与原来的基础类区分开。
1. 为衍生类添加新函数（功能）。
2. 是改变基础类一个现有函数的行为。（重写）

##### 1.5.2 等价与类似关系
？

#### 1.6多形对象的互换使用

把衍生类型当作它的基本类型处理的过程叫作“Upcasting”

#### 1.6.1 动态绑定
**多态性（Polymorphism）**
将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫
作“多态性”（Polymorphism）。
**动态绑定**
对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。
#### 1.6.2 抽象的基础类和接口
abstract
abstract类
abstract方法
interface
#### 1.7 对象的创建和存在时间

**对象的创建**
数据的存储，如何控制对象的存在时间
C++为例
1. 存储以及存在时间可在编写程序时决定；只需将对象放置在堆栈或静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。
	- 不灵活，编写时就必须知道对象的准确数量、存在时间、类型
2. 在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。这些参数都在程序正式运行时才决定的。
	- 灵活，需要新对象时，秩序在内存堆里简单创建
	- 由于存储空间的关联是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。
	- 动态创建方法使对象本来就倾向于复杂，所以查找存储空间以及释放它所需的额外开销不会为对象的创建造成明显的影响。

C++允许我们决定是在写程序时创建对象，还是在运行期间创建，这种控制方法更加灵活。
**对象的破坏**
若在堆栈或者静态存储空间里创建一个对象，编译器会判断对象的持续时间有多长，到时会自动“破坏”或者“清除”它。
程序员可用两种方法来破坏一个对
象：
- 用程序化的方式决定何时破坏对象
- 利用由运行环境提供的一种“垃圾收集器”特性，自动寻找那些不再使用的对象，并将其清除。

##### 1.7.1 集合与继承器
**集合：**
用于解决特定问题的新型对象容纳了指向其他对象的句柄。在需要的时候，集合会自动扩充自
己，以便适应我们在其中置入的任何东西。所以我们事先不必知道要在一个集合里容下多少东西。只需创建一个集合，以后的工作让它自己负责好了。

**继承器（Iterator）**
- 它属于一种对象，负责选择集合内的元素，并把它们提供给继承器的用户。
- 通过继承器的作用，集合被抽象成一个简单的序列。继承器允许我们遍历那个序列，同时毋需关心基础结构是什么——换言之，不管它是一个矢量、一个链接列表、一个堆栈，还是其他什么东西。

**集合的选择**
如果一种类型的序列即可满足我们的所有要求，那么完全没有必要再换用不同的类型。有两方面的原因促使我们需要对集合作出选择：

1. 集合提供了不同的接口类型以及外部行为

> 堆栈的接口与行为与队列的不同，而队列的接口与行为又与一个集（Set）或列表的不同。利用这个特征，我们解决问题时便有更大的灵活性。

2. 不同的集合在进行特定操作时往往有不同的效率

> 最好的例子便是矢量（Vector）和列表（List）的
区别。它们都属于简单的序列，拥有完全一致的接口和外部行为。但在执行一些特定的任务时，需要的开销却是完全不同的。对矢量内的元素进行的随机访问（存取）是一种常时操作；无论我们选择的选择是什么，需要的时间量都是相同的。但在一个链接列表中，若想到处移动，并随机挑选一个元素，就需付出“惨重”的代价。而且假设某个元素位于列表较远的地方，找到它所需的时间也会长许多。但在另一方面，如果想在
序列中部插入一个元素，用列表就比用矢量划算得多。

##### 1.7.2 单根结构
**单根结构:**
所有类最终都从单独一个基础类继承。这个终级基础类的名字很简单，就是一个“Object”。
**优点：**
1. 一个单根结构，加上所有对象都在内存堆中创建，可以极大简化参数的传递
2. 利用单根结构，我们可以更方便地实现一个垃圾收集器。与此有关的必要支持可安装于基础类中，而垃圾收集器可将适当的消息发给系统内的任何对象。如果没有这种单根结构，而且系统通过一个句柄来操纵对象，那么实现垃圾收集器的途径会有很大的不同，而且会面临许多障碍。
3. 由于运行期的类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。这对系统级的操作来说显得特别重要，比如违例控制；
4. 能在程序设计时获得更大的灵活性。

##### 1.7.3 集合库与方便使用集合

下溯造型与模板／通用性

下溯造型：强转
> 上溯造型成 Object，这样便丢失了它的身份或者标识信息。再次使用它的时候，会得到一个Object 句柄，而非指向我们早先置入的那个类型的句柄。下溯造型成一种更“特殊”的类型以解决这个问题。

模板／通用性：泛型
> 下溯造型和运行期检查都要求花额外的时间来运行程序，而且程序员必须付出额外的精力。创建一个“智能”集合，令其知道自己容纳的类型来提高效率

#### 1.8 违例控制：解决错误

Exception

#### 1.9 多线程
同时对多个任务加以控制。
有些时候，中断对那些实时性很强的任务来说是很有必要的。但还存在其他许多问题，它们只要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。
synchronized 

#### 1.10 永久性
#### 1.11 Java 和因特网
C/S
client/server
事务处理:对数据库进行操作
中间件

客户端编程
1. 插件
2. 脚本编制语言
3. java
4. ActiveX

服务器端编程
1. Perl
2. CGI
3. JAVA

#### 1.12 分析和设计

#### 1.13 Java 还是 C++ ？

## 第 2 章 一切都是对象
### 2.1 用句柄操纵对象
在 Java 里都得到了简化，任何东西都可看作对象。因此，我们可采用一种统一的语法，任何地方均可照搬不误。但要注意，尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“句柄”（Handle）。


```
此外，即使没有电视机，遥控板亦可独立存在。也就是说，只是由于拥有一个句柄，并不表示必须有一个对象同它连接。所以如果想容纳一个词或句子，可创建一个 String 句柄：
String s;
但这里创建的只是句柄，并不是对象。
String s = "asdf";
```
### 2.2 所有对象都必须创建
#### 2.2.1 保存到什么地方
> 程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据

**1. 寄存器**
	这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存
器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。

**2. 堆栈**
驻留于常规 RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆
栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管***有些 Java 数据要保存在堆栈里——特别是对象句柄***，***但Java 对象并不放到其中。***

**3. 堆(Heap)**
一种常规用途的内存池（也在 RAM 区域），***其中保存了Java 对象***。
和堆栈不同，“内存堆”或
“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。
要求创建一个对象时，只需用new 命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然
会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！

**4. 静态存储**
这儿的“静态”（Static）是指“位于固定位置”（尽管也在 RAM 里）。程序运行期间，静态存储的数据将随时等候调用。可用static 关键字指出一个对象的特定元素是静态的。***但 Java 对象本身永远都不会置入静态存储空间。***

**5. 常数存储**
常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。
**6. 非RAM存储**
若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。

#### 2.2.2 特殊情况：主要类型
有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用 new 创建对象（特别是小的、简单的变量）并不是非常有效，因为**new 将对象置于“堆”里**。对于这些类型，Java 采纳了与 C 和 C++相同的方法。也就是说，**不是用new 创建变量，而是创建一个并非句柄的“自动”变量。这个变量容纳了具体的值，*并置于堆栈中*，**能够更高效地存取。

Java 决定了每种主要类型的大小。就象在大多数语言里那样，这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是 Java 程序具有很强移植能力的原因之一。

boolean 1 位 - - Boolean
char 16 位 Unicode 0 Unicode 2 的 16 次方-1 Character
byte 8 位 -128 +127 Byte
short 16 位 -2 的15 次方 +2 的 15 次方-1 Short
int 32 位 -2 的 31 次方 +2 的31 次方-1 Integer
long 64 位 -2 的63 次方 +2 的 63 次方-1 Long
float 32 位 IEEE754 IEEE754 Float
double 64 位 IEEE754 IEEE754 Double
Void - - - Void






