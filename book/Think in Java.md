# Think in Java
## 第一章
### 1.对象入门
#### 1.1抽象的进步
Smalltalk 的五大基本特征
(1) 所有东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论
上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。
(2) 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那
28
个对象“发送一条消息”。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个
子例程或函数。
(3) 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所
以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。
(4) 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）
是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。
(5) 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为
“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消
息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括
“圆”。这一特性称为对象的“可替换性”，是OOP 最重要的概念之一。

#### 1.2对象的接口
我们向对象发出
的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类
型”与“接口”的等价或对应关系是面向对象程序设计的基础。
#### 1.3实现方案的隐藏
- **两种涉足面向对象编程的人员：**
>  1. **类的创建者：**创建新数据类型的人
>  对类创建者来说，他们的目标则是从头构建一个类，只向客户程序员开放有必要开放的东西（接口），其他所有细节都隐藏起来。
>  2. **客户程序员：**在自己的应用程序中采用现成数据类型的人
	> 对客户程序员来讲，最主要的目标就是收集一个充斥着各种类的编程“工具
箱”，以便快速开发符合自己要求的应用。

- **接口：**规定了可对一个特定的对象发出哪些请求。
- **隐藏的实现：**然而，必须在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”

- **类边界**
Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private，protected 以及暗示性的friendly。
> - **public:**意味着后续的定义任何人均可使用
> - **private:**意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。 private 在您与客户程序员之间竖起了一堵墙。若有人试图访问私有30成员，就会得到一个编译期错误。
> - **friendly:**涉及“包装”或“封装”（Package）的概念——即Java 用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。
> - **protected:**与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。

#### 1.4方案的重复使用
> 创建并测试好一个类后，它应（从理想的角度）代表一个有用的代码单位。但并不象许多人希望的那样，这种重复使用的能力并不容易实现；它要求较多的经验以及洞察力，这样才能设计出一个好的方案，才有可能重复使用。许多人认为代码或设计方案的重复使用是面向对象的程序设计提供的最伟大的一种杠杆。

- **成员对象：**为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。
- **组织——在现有类的基础上组织一个新类：**新类可由任意数量和类型的其他对象构成。无论如何，只要新类达到了设计要求即可。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。

#### 1.5 继承：重新使用接口
extends
使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏
起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消
息亦可原样发给衍生类的对象。根据可以发送的消息，我们能知道类的类型。这意味着衍生类具有与基础类
相同的类型！为真正理解面向对象程序设计的含义，首先必须认识到这种类型的等价关系。

两种做法可将新得的衍生类与原来的基础类区分开。
1. 为衍生类添加新函数（功能）。
2. 是改变基础类一个现有函数的行为。（重写）

##### 1.5.2 等价与类似关系
？

#### 1.6多形对象的互换使用

把衍生类型当作它的基本类型处理的过程叫作“Upcasting”

#### 1.6.1 动态绑定
**多态性（Polymorphism）**
将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫
作“多态性”（Polymorphism）。
**动态绑定**
对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。
#### 1.6.2 抽象的基础类和接口
abstract
abstract类
abstract方法
interface
#### 1.7 对象的创建和存在时间

**对象的创建**
数据的存储，如何控制对象的存在时间
C++为例
1. 存储以及存在时间可在编写程序时决定；只需将对象放置在堆栈或静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。
	- 不灵活，编写时就必须知道对象的准确数量、存在时间、类型
2. 在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。这些参数都在程序正式运行时才决定的。
	- 灵活，需要新对象时，秩序在内存堆里简单创建
	- 由于存储空间的关联是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。
	- 动态创建方法使对象本来就倾向于复杂，所以查找存储空间以及释放它所需的额外开销不会为对象的创建造成明显的影响。

C++允许我们决定是在写程序时创建对象，还是在运行期间创建，这种控制方法更加灵活。
**对象的破坏**
若在堆栈或者静态存储空间里创建一个对象，编译器会判断对象的持续时间有多长，到时会自动“破坏”或者“清除”它。
程序员可用两种方法来破坏一个对
象：
- 用程序化的方式决定何时破坏对象
- 利用由运行环境提供的一种“垃圾收集器”特性，自动寻找那些不再使用的对象，并将其清除。

##### 1.7.1 集合与继承器
**集合：**
用于解决特定问题的新型对象容纳了指向其他对象的句柄。在需要的时候，集合会自动扩充自
己，以便适应我们在其中置入的任何东西。所以我们事先不必知道要在一个集合里容下多少东西。只需创建一个集合，以后的工作让它自己负责好了。

**继承器（Iterator）**
- 它属于一种对象，负责选择集合内的元素，并把它们提供给继承器的用户。
- 通过继承器的作用，集合被抽象成一个简单的序列。继承器允许我们遍历那个序列，同时毋需关心基础结构是什么——换言之，不管它是一个矢量、一个链接列表、一个堆栈，还是其他什么东西。

**集合的选择**
如果一种类型的序列即可满足我们的所有要求，那么完全没有必要再换用不同的类型。有两方面的原因促使我们需要对集合作出选择：

1. 集合提供了不同的接口类型以及外部行为

> 堆栈的接口与行为与队列的不同，而队列的接口与行为又与一个集（Set）或列表的不同。利用这个特征，我们解决问题时便有更大的灵活性。

2. 不同的集合在进行特定操作时往往有不同的效率

> 最好的例子便是矢量（Vector）和列表（List）的
区别。它们都属于简单的序列，拥有完全一致的接口和外部行为。但在执行一些特定的任务时，需要的开销却是完全不同的。对矢量内的元素进行的随机访问（存取）是一种常时操作；无论我们选择的选择是什么，需要的时间量都是相同的。但在一个链接列表中，若想到处移动，并随机挑选一个元素，就需付出“惨重”的代价。而且假设某个元素位于列表较远的地方，找到它所需的时间也会长许多。但在另一方面，如果想在
序列中部插入一个元素，用列表就比用矢量划算得多。

##### 1.7.2 单根结构
**单根结构:**
所有类最终都从单独一个基础类继承。这个终级基础类的名字很简单，就是一个“Object”。
**优点：**
1. 一个单根结构，加上所有对象都在内存堆中创建，可以极大简化参数的传递
2. 利用单根结构，我们可以更方便地实现一个垃圾收集器。与此有关的必要支持可安装于基础类中，而垃圾收集器可将适当的消息发给系统内的任何对象。如果没有这种单根结构，而且系统通过一个句柄来操纵对象，那么实现垃圾收集器的途径会有很大的不同，而且会面临许多障碍。
3. 由于运行期的类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。这对系统级的操作来说显得特别重要，比如违例控制；
4. 能在程序设计时获得更大的灵活性。

##### 1.7.3 集合库与方便使用集合

下溯造型与模板／通用性

下溯造型：强转
> 上溯造型成 Object，这样便丢失了它的身份或者标识信息。再次使用它的时候，会得到一个Object 句柄，而非指向我们早先置入的那个类型的句柄。下溯造型成一种更“特殊”的类型以解决这个问题。

模板／通用性：泛型
> 下溯造型和运行期检查都要求花额外的时间来运行程序，而且程序员必须付出额外的精力。创建一个“智能”集合，令其知道自己容纳的类型来提高效率

#### 1.8 违例控制：解决错误

Exception

#### 1.9 多线程
同时对多个任务加以控制。
有些时候，中断对那些实时性很强的任务来说是很有必要的。但还存在其他许多问题，它们只要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。
synchronized 

#### 1.10 永久性
#### 1.11 Java 和因特网
C/S
client/server
事务处理:对数据库进行操作
中间件

客户端编程
1. 插件
2. 脚本编制语言
3. java
4. ActiveX

服务器端编程
1. Perl
2. CGI
3. JAVA

#### 1.12 分析和设计

#### 1.13 Java 还是 C++ ？

## 第 2 章 一切都是对象
### 2.1 用句柄操纵对象
在 Java 里都得到了简化，任何东西都可看作对象。因此，我们可采用一种统一的语法，任何地方均可照搬不误。但要注意，尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“句柄”（Handle）。


```
此外，即使没有电视机，遥控板亦可独立存在。也就是说，只是由于拥有一个句柄，并不表示必须有一个对象同它连接。所以如果想容纳一个词或句子，可创建一个 String 句柄：
String s;
但这里创建的只是句柄，并不是对象。
String s = "asdf";
```
### 2.2 所有对象都必须创建
#### 2.2.1 保存到什么地方
> 程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据

**1. 寄存器**
	这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存
器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。

**2. 堆栈**
驻留于常规 RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆
栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java 编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管***有些 Java 数据要保存在堆栈里——特别是对象句柄***，***但Java 对象并不放到其中。***

**3. 堆(Heap)**
一种常规用途的内存池（也在 RAM 区域），***其中保存了Java 对象***。
和堆栈不同，“内存堆”或
“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。
要求创建一个对象时，只需用new 命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然
会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！

**4. 静态存储**
这儿的“静态”（Static）是指“位于固定位置”（尽管也在 RAM 里）。程序运行期间，静态存储的数据将随时等候调用。可用static 关键字指出一个对象的特定元素是静态的。***但 Java 对象本身永远都不会置入静态存储空间。***

**5. 常数存储**
常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。
**6. 非RAM存储**
若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。

#### 2.2.2 特殊情况：主要类型
有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用 new 创建对象（特别是小的、简单的变量）并不是非常有效，因为**new 将对象置于“堆”里**。对于这些类型，Java 采纳了与 C 和 C++相同的方法。也就是说，**不是用new 创建变量，而是创建一个并非句柄的“自动”变量。这个变量容纳了具体的值，*并置于堆栈中*，**能够更高效地存取。

Java 决定了每种主要类型的大小。就象在大多数语言里那样，这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是 Java 程序具有很强移植能力的原因之一。

boolean 1 位 - - Boolean
char 16 位 Unicode 0 Unicode 2 的 16 次方-1 Character
byte 8 位 -128 +127 Byte
short 16 位 -2 的15 次方 +2 的 15 次方-1 Short
int 32 位 -2 的 31 次方 +2 的31 次方-1 Integer
long 64 位 -2 的63 次方 +2 的 63 次方-1 Long
float 32 位 IEEE754 IEEE754 Float
double 64 位 IEEE754 IEEE754 Double
Void - - - Void

数值类型全都是有符号（正负号）的，所以不必费劲寻找没有符号的类型。
主数据类型也拥有自己的“封装器”（wrapper）类。这意味着假如想让堆内一个非主要对象表示那个主类型，就要使用对应的封装器。例如：
char c = 'x';
Character C = new Character('c');
也可以直接使用：
Character C = new Character('x');

**1. 高精度数字**
Java 1.1 增加了两个类，用于进行高精度的计算：BigInteger 和 BigDecimal。尽管它们大致可以划分为“封装器”类型，但两者都没有对应的“主类型”。

这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。也就是说，能对int 或 float 做的事情，对BigInteger 和BigDecimal 一样可以做。只是必须使用方法调用，不能使用运算符。此外，由于牵涉更多，所以运算速度会慢一些。我们牺牲了速度，但换来了精度。

- BigInteger 支持任意精度的整数。也就是说，我们可精确表示任意大小的整数值，同时在运算过程中不会丢失任何信息。
- BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。

#### 2.2.3 Java 的数组
Java 的一项主要设计目标就是安全性。所以在 C 和 C++里困扰程序员的许多问题都未在Java 里重复。一个Java 可以保证被初始化，而且不可在它的范围之外访问。由于系统自动进行范围检查，所以必然要付出一些代价：针对每个数组，以及在运行期间对索引的校验，都会造成少量的内存开销。但由此换回的是更高的安全性，以及更高的工作效率。为此付出少许代价是值得的。

创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始化成一个特殊值，并带有自己的关键字：null（空）。一旦 Java 看到null，就知道该句柄并未指向一个对象。正式使用前，必须为每个句柄都分配一个对象。

也可以创建主类型数组。同样地，编译器能够担保对它的初始化，因为会将那个数组的内存划分成零。


### 2.3 绝对不要清除对象
#### 2.3.1 作用域
大多数程序设计语言都提供了“作用域”（Scope）的概念。对于在作用域里定义的名字，作用域同时决定了它的“可见性”以及“存在时间”。
#### 2.3.2 对象的作用域
Java 对象不具备与主类型一样的存在时间。用 new 关键字创建一个Java 对象的时候，它会超出作用域的范围之外。所以假若使用下面这段代码：
```
{
String s = new String("a string");
} /* 作用域的终点 */
```

那么句柄s 会在作用域的终点处消失。然而，s 指向的 String 对象依然占据着内存空间。这在C和C++里需要释放内存，不然会一直占用着。但是java会通过“垃圾收集器”来对这些不再引用的对象进行释放，它会查找用new 创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。
### 2.4 新建数据类型：类（Class）
#### 2.4.1 字段和方法
定义一个类时，可在自己的类里设置两种类型的元素：数据成员（有时也叫“字段”）以及成员函数（通常叫“方法”）。
其中，数据成员是一种对象（通过它的句柄与其通信），可以为任何类型。它也可以是主类型（并不是句柄）之一。
1. 主类型成员的默认值
若某个主数据类型属于一个类成员，那么即使不明确（显式）进行初始化，也可以保证它们获得一个默认值。

然而，这种保证却并不适用于“局部”变量——那些变量并非一个类的字段。所以，假若在一个函数定义中写入下述代码：

    int x;
那么x 会得到一些随机值（这与C 和C++是一样的），不会自动初始化成零。

### 2.5 方法、自变量和返回值
最基本的形式：
返回类型 方法名( /* 自变量列表*/ ) {/* 方法主体 */}

返回类型是指调用方法之后返回的数值类型。显然，方法名的作用是对具体的方法进行标识和引用。自变量
列表列出了想传递给方法的信息类型和名称。

Java 的方法只能作为类的一部分创建。只能针对某个对象调用一个方法（“静态”方法可针对类调用，毋需一个对象），而且那个对象必须能够
执行那个方法调用。

#### 2.5.1 自变量列表
我们传递对象时，通常是传递的句柄，而传递基本数据类型时是值传递，String的传递有点特殊，之后再讨论。

若返回类型为void时，return关键字唯一的作用就是退出方法。

### 2.6构建Java程序

#### 2.6.1名字的可见性
在C++里解决命名冲突的问题使用的是命名空间的概念。
Java采用全新的机制，所以Java能完全避免这些问题，为了给库生成确定的名字，采用了与internet域名类似的名字。事实上Jav的设计者鼓励程序员反转自己的Inteernet域名，因为他们肯定是独一无二的。比如com.linfon.myread.utils。
反转了域名后，可将点号想像成子目录。
java1.0和1.1中域扩展名com，edu，org，net等都约定为大写形式。所以库的样子就编程COM.linfon....然而，在Java1.2的开发过程中，设计者发现这样做会造成一些问题。所以目前整个软件包都以小写字母为标准。
Java这种特殊的机制意味所有文件都自动存在于自己的命名空间里。而且每一个文件里的每个类都自动获得一个独一无二的标识符(当然，一个文件里的类名必须是唯一的)。所以不必学习特殊的语言知识来解决这个问题--语言本身已经帮我们照顾到这一点。

#### 2.6.2使用其他组件

import--指示编译器导入一个类库。
import java.util.Vector;
import java.util*;
#### 2.6.3 static关键字
static使用的两种情况
1.只想用一个存储区域来保存一个特定的数据---无论要创建多少个对象，甚至根本不用创建你对象。
2.我们需要一个特殊的方法，他没有雨这个类的任何对象关联，也就是说即使没有创建对象，也需要一个能调用的方法。

static:
一旦将什么东西设置为static，数据或方法就不会同那个类的任何对象实例联系到一起。
### 2.8 注释和嵌入文档
//单行注释
/* 多行注释 */
#### 2.8.1注释文档
Java考虑到文档文虎问题，文档与代码分离每次更改代码都需要改变文档，这样的维护起来相当麻烦。java的解决方法，将文档与代码连接起来，将所文档与代码置于同一个文件。然而为了实整齐划一需要用两种东西辅助:
1.特殊的注释语法:/\*\* 文档注释 */
2.用于提取注释的工具:javadoc

- **javadoc：**

	> 它采用了部分来自Java 编译器的技术，查找我们置入程序的特殊注释标记。它不仅提取由这些标记指示的信息，也将毗邻注释的类名或方法名提取出来。这样一来，我们就可用最轻的工作量，生成十分专业的程序文档

	javadoc输出的是一个HTML文件，可以用自己的web浏览器查看。

- **文档注释：**
所有的javadoc命令都只能出现于/\*\*注释中。*/。
两种方式使用javadoc命令:
1.嵌入的HTML
2.使用文档标记:@

三种类型的注释文档：
	1. 类注释：位于一个类定义之前
	2. 变量注释：位于变量定义之
	3. 方法注释：位于一个方法定义的前面
	 > /\*\* 一个类注释 */
	public class docTest {
	/\*\* 一个变量注释 */
	public int i;
	/\*\* 一个方法注释 */
	public void f() {}
	}
	
注意javadoc只能为public和protected成员处理注释文档。private和friendly成员你的注释会被忽略，我们看不到任何输出(可以用-private标记包括private成员)。这样设计的原因是，因为只有public 和protected 成员才可在文件之外使用，这是客户程序员的希
望。
上述代码的输出是一个HMTL文件，他与其他Java文档具有相同的标准格式。设计程序时，请务必考虑输入上述代码，用 javadoc 处理一下

#### 2.8.2嵌入HTML

javadoc 将 HTML 命令传递给最终生成的 HTML 文档。这便使我们能够充分利用HTML 的巨大威力。当然，我们
的最终动机是格式化代码，不是为了哗众取宠。下面列出一个例子：
/\*\*
\* < pre>
\* System.out.println(new Date());
\* < /pre>
*/
亦可象在其他Web 文档里那样运用 HTML，对普通文本进行格式化，使其更具条理、更加美观：
/\*\*
57
\* 您< em>甚至< /em>可以插入一个列表：
\* < ol>
\* < li> 项目一
\* < li> 项目二
\* < li> 项目三
\* < /ol>
*/
注意在文档注释中，位于一行最开头的星号会被javadoc 丢弃。同时丢弃的还有前导空格。javadoc 会对所有内容进行格式化，使其与标准的文档外观相符。不要将< h1>或< hr>这样的标题当作嵌入 HTML 使用，因为javadoc 会插入自己的标题，我们给出的标题会与之冲撞。
所有类型的注释文档——类、变量和方法——都支持嵌入 HTML

#### 2.8.4 @see ：引用其他类
所有三种类型的注释文档都可包含@see 标记，它允许我们引用其他类里的文档。对于这个标记，javadoc 会
生成相应的 HTML，将其直接链接到其他文档。格式如下：
@see 类名
@see 完整类名
@see 完整类名#方法名
每一格式都会在生成的文档里自动加入一个超链接的“See Also”（参见）条目。注意 javadoc 不会检查我
们指定的超链接，不会验证它们是否有效。

#### 2.8.5 类文档标记
随同嵌入HTML 和@see 引用，类文档还可以包括用于版本信息以及作者姓名的标记。类文档亦可用于“接口”目的（本书后面会详细解释）。
1. @version
格式如下：
@version 版本信息
其中，“版本信息”代表任何适合作为版本说明的资料。若在 javadoc 命令行使用了“-version”标记，就会从生成的 HTML 文档里提取出版本信息。
2. @author
格式如下：
@author 作者信息
其中，“作者信息”包括您的姓名、电子函件地址或者其他任何适宜的资料。若在javadoc 命令行使用了“-author”标记，就会专门从生成的HTML 文档里提取出作者信息。可为一系列作者使用多个这样的标记，但它们必须连续放置。全部作者信息会一起存入最终 HTML 代码的单独一个段落里。
#### 2.8.6 变量文档标记
变量文档只能包括嵌入的HTML 以及@see 引用。
#### 2.8.7 方法文档标记
除嵌入 HTML 和@see 引用之外，方法还允许使用针对参数、返回值以及违例的文档标记。
1. @param
格式如下：
@param 参数名 说明
其中，“参数名”是指参数列表内的标识符，而“说明”代表一些可延续到后续行内的说明文字。一旦遇到一个新文档标记，就认为前一个说明结束。可使用任意数量的说明，每个参数一个。
2. @return
格式如下：
@return 说明
其中，“说明”是指返回值的含义。它可延续到后面的行内。
3. @exception
有关“违例”（Exception）的详细情况，我们会在第 9 章讲述。简言之，它们是一些特殊的对象，若某个方法失败，就可将它们“扔出”对象。调用一个方法时，尽管只有一个违例对象出现，但一些特殊的方法也许能产生任意数量的、不同类型的违例。所有这些违例都需要说明。所以，违例标记的格式如下：
@exception 完整类名 说明
其中，“完整类名”明确指定了一个违例类的名字，它是在其他某个地方定义好的。而“说明”（同样可以延续到下面的行）告诉我们为什么这种特殊类型的违例会在方法调用中出现。
4. @deprecated
这是Java 1.1 的新特性。该标记用于指出一些旧功能已由改进过的新功能取代。该标记的作用是建议用户不必再使用一种特定的功能，因为未来改版时可能摒弃这一功能。若将一个方法标记为@deprecated，则使用该方法时会收到编译器的警告。

## 第 3 章 控制程序流程
### 3.1 使用 Java 运算符
几乎所有运算符都只能操作“主类型”(primitives)。唯一的例是“=”、“==”和“!=”，它们能操作所有对象（也是对象易令人混淆的一个地方）。除此以外，String 类支持“+”和“+=”。
#### 3.1.1 优先级
最简单的规则就是乘法和除法在加法和减法之前完成。程序员经常都会忘记其他优先级规则，所
以应该用括号明确规定计算顺序。
#### 3.1.2 赋值
赋值是用等号运算符：=
变量=常量/变量/表达式
左边的值必须是一个明确的、已命名的变量。也就是说，它必须有一个物理性的空间来保存右边的值。
**赋值场景：**
1. 基本类型的赋值就是简单的复制值，然后赋值。
2. 对象的赋值时，传递的是对象的句柄，让两个变量都指向了同一个对象。
#### 3.1.3 算术运算符
加号（+）
减号（-）
除号（/）
乘号（*）
模数（%，从整数除法中获得余数）。

 一元加、减运算符
一元减号（-）和一元加号（+）与二元加号和减号都是相同的运算符。根据表达式的书写形式，编译器会自动判断使用哪一种。例如下述语句：
x = -a;
它的含义是显然的。编译器能正确识别下述语句：
x = a * -b;
但读者会被搞糊涂，所以最好更明确地写成：
x = a * (-b);
一元减号得到的运算对象的负值。一元加号的含义与一元减号相反，虽然它实际并不做任何事情。
#### 3.1.4 自动递增和递减
i++
++i
i--
--i

#### 3.1.5 关系运算符
关系运算符生成的是一个“布尔”（Boolean）结果。
小于（<）
大于（>）
小于或等于（<=）
大于或等于（>=）
等于（==）
不等于（!=）

检查对象是否相等
关系运算符==和!=也适用于所有对象，==和!=比较的是对象句柄。
若想对比两个对象的实际内容是否相同，必须使用所有对象都适用的特殊方法equals()。但这个方法不适用于“主类型”，那些类型直接使用==和!=即可。

#### 3.1.6 逻辑运算符