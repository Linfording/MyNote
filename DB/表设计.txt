	主键:
		1)UUID(32/36),理论全局唯一,分布式数据库,数据量很大(mysql单表千万,oracle单表亿；随着数据量增加到一个临界值，查询性能急剧降低,数据库优化:拆表)
		2)int,性能最高	电商大多集中式的数据库
		3)long,其次,容纳值更多

		ht全球范围,数据量大,数据库拆分多,uuid更适合
		电商的数据表会尽量集中,结算金额等等通过一张表会更高效,long更适合

		分布式数据库,大项目,性能要求不是最顶级的,可以使用uuid
		为了性能的情况下,尽量进行单表,使用long

	表设计:
		1)主键,汇通uuid,jt自增long		
		2)价格,long	2480.00*24800,位了性能整形效率高于浮点;页面/100(js完成这个工作)
		3)图片,默认最少5张图片
			a)	传统:写入数据库,blog/clog大字段。性能低!大字段会引起索引失效
			b)	主流:不会在主表中写大字段,图片,直接保存在磁盘目录中,保存相对路径
		4)cid外键,业务外键,数据库不做外键约束,还是为了性能。对象是普通属性,数据的一致性(代码)
		5)状态status,1正常,2下架,3删除
		6)修改日期,新增时也写入。目的:为了排序(按修改时间倒叙,列表常用方式)

	索引:
		1)索引为什么快?
			a)把当前表的部分内容又形成一个索引表,字段少,快!
			b)索引真正快的原因:索引表里做了排序,大大减少了查询次数;
				比如100W数据的表,全表查询做100W次,而排序后进行比较,折半查找,查找次数指数下降
		问题:
			a)占空间,数据量大之后索引表的性能又下降了,此时在索引表上再建立索引,这样就增加了维护工作
			b)排序一次,
			c)表的数据跟新,索引也要更新,耗费额外的时间
		结论:
			不能随便创建索引
		2)哪些字段创建索引?还是所有的字段都创建索引?
			这个字段常出现在where中,orderby中

			where:
				cid
				status
				title
			orderby:
				updated