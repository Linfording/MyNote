1.二分查找
	1.数据已经是排序好了的
	2.得到数组的开始位置start和结束位置end
	3.取中间位置的数据a[mid]
	4.跟等待查找数据data进行比较若a[mid]>data,则取end=mid-1;否则取start=a[mid]+1;若a[mid]=data则直接返回当前mid为查找到的位置。依次遍历直到找到数据,或者最终没有该数据。

2.排序算法
2.1冒泡排序
	1.冒泡排序具有稳定性
	2.时间复杂度O(n^2)
	3.依次比较相邻的两个元素,小的放前面,大的放后面
	
2.2快速排序
	1.不稳定，
	2.时间复杂度 最理想 O(nlogn) 最差时间O(n^2)
	3.快速排序是对冒泡排序的一种本质改进。。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。

2.3选择排序
	1.不稳定
	2.时间复杂度 O(n^2)
	3.每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 
	
2.4插入排序
	1.稳定
	2.时间复杂度O(n^2)
	3.经过i-1遍处理后L[1,..i-1]已排序好。第i遍处理仅将L[i]插入L[1,..i-1]的适当位置,使得l[1..i]又是排好序的序列
	可以采用顺序比较
	首先比较L[i] 和 L[i-1],如果L[i-1]<=L[i],则L[1..i]已经排好序,第i遍处理就结束了;否则交换L[i]与L[i-1]的位置,继续比较L[i-1]和L[i-2],直到找到某一个位置j(1<=j<=i-1),使得L[j]<=L[j+1]时为止。