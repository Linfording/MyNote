# Think in Java
## 第一章
### 1.对象入门
#### 1.1抽象的进步
Smalltalk 的五大基本特征
(1) 所有东西都是对象。可将对象想象成一种新型变量；它保存着数据，但可要求它对自身进行操作。理论
上讲，可从要解决的问题身上提出所有概念性的组件，然后在程序中将其表达为一个对象。
(2) 程序是一大堆对象的组合；通过消息传递，各对象知道自己该做些什么。为了向对象发出请求，需向那
28
个对象“发送一条消息”。更具体地讲，可将消息想象为一个调用请求，它调用的是从属于目标对象的一个
子例程或函数。
(3) 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所
以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。
(4) 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）
是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。
(5) 同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法，大家不久便能理解。由于类型为
“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消
息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括
“圆”。这一特性称为对象的“可替换性”，是OOP 最重要的概念之一。

#### 1.2对象的接口
我们向对象发出
的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类
型”与“接口”的等价或对应关系是面向对象程序设计的基础。
#### 1.3实现方案的隐藏
- **两种涉足面向对象编程的人员：**
>  1. **类的创建者：**创建新数据类型的人
>  对类创建者来说，他们的目标则是从头构建一个类，只向客户程序员开放有必要开放的东西（接口），其他所有细节都隐藏起来。
>  2. **客户程序员：**在自己的应用程序中采用现成数据类型的人
	> 对客户程序员来讲，最主要的目标就是收集一个充斥着各种类的编程“工具
箱”，以便快速开发符合自己要求的应用。

- **接口：**规定了可对一个特定的对象发出哪些请求。
- **隐藏的实现：**然而，必须在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”

- **类边界**
Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private，protected 以及暗示性的friendly。
> - **public:**意味着后续的定义任何人均可使用
> - **private:**意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。 private 在您与客户程序员之间竖起了一堵墙。若有人试图访问私有30成员，就会得到一个编译期错误。
> - **friendly:**涉及“包装”或“封装”（Package）的概念——即Java 用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。
> - **protected:**与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。

#### 1.4方案的重复使用
> 创建并测试好一个类后，它应（从理想的角度）代表一个有用的代码单位。但并不象许多人希望的那样，这种重复使用的能力并不容易实现；它要求较多的经验以及洞察力，这样才能设计出一个好的方案，才有可能重复使用。许多人认为代码或设计方案的重复使用是面向对象的程序设计提供的最伟大的一种杠杆。

- **成员对象：**为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。
- **组织——在现有类的基础上组织一个新类：**新类可由任意数量和类型的其他对象构成。无论如何，只要新类达到了设计要求即可。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。

#### 1.5 继承：重新使用接口
extends
使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏
起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消
息亦可原样发给衍生类的对象。根据可以发送的消息，我们能知道类的类型。这意味着衍生类具有与基础类
相同的类型！为真正理解面向对象程序设计的含义，首先必须认识到这种类型的等价关系。

两种做法可将新得的衍生类与原来的基础类区分开。
1. 为衍生类添加新函数（功能）。
2. 是改变基础类一个现有函数的行为。（重写）

##### 1.5.2 等价与类似关系
？

#### 1.6多形对象的互换使用

把衍生类型当作它的基本类型处理的过程叫作“Upcasting”

#### 1.6.1 动态绑定
**多态性（Polymorphism）**
将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫
作“多态性”（Polymorphism）。
**动态绑定**
对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。
#### 1.6.2 抽象的基础类和接口
abstract
abstract类
abstract方法
interface
#### 1.7 对象的创建和存在时间

**对象的创建**
数据的存储，如何控制对象的存在时间
C++为例
1. 存储以及存在时间可在编写程序时决定；只需将对象放置在堆栈或静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。
	- 不灵活，编写时就必须知道对象的准确数量、存在时间、类型
2. 在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。这些参数都在程序正式运行时才决定的。
	- 灵活，需要新对象时，秩序在内存堆里简单创建
	- 由于存储空间的关联是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。
	- 动态创建方法使对象本来就倾向于复杂，所以查找存储空间以及释放它所需的额外开销不会为对象的创建造成明显的影响。

C++允许我们决定是在写程序时创建对象，还是在运行期间创建，这种控制方法更加灵活。
**对象的破坏**
若在堆栈或者静态存储空间里创建一个对象，编译器会判断对象的持续时间有多长，到时会自动“破坏”或者“清除”它。
程序员可用两种方法来破坏一个对
象：

